<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tdmaker.github.io/randy-blogs/</id>
    <title>性感知识，在线分享</title>
    <updated>2019-06-29T01:48:31.601Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tdmaker.github.io/randy-blogs/"/>
    <link rel="self" href="https://tdmaker.github.io/randy-blogs//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tdmaker.github.io/randy-blogs//images/avatar.png</logo>
    <icon>https://tdmaker.github.io/randy-blogs//favicon.ico</icon>
    <rights>All rights reserved 2019, 性感知识，在线分享</rights>
    <entry>
        <title type="html"><![CDATA[对于医疗项目框架的讲述——前端部分]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/an-explanation-of-medical-frameworks</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/an-explanation-of-medical-frameworks">
        </link>
        <updated>2019-06-26T05:54:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><em>只讲组织结构和如何使用，如何实现可以看源码。不涉及怎样使用 Angular 以及其他相关技术</em></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><em>只讲组织结构和如何使用，如何实现可以看源码。不涉及怎样使用 Angular 以及其他相关技术</em></p>
</blockquote>
<!--more-->
<h2 id="目录结构">目录结构</h2>
<ul>
<li>path-to-your-project/src/app/components：存储我定义的一些<strong>可复用组件</strong>，作用根据名称一目了然；</li>
<li>path-to-your-project/src/app/container：存储网站主<strong>业务框架</strong>；</li>
<li>path-to-your-project/src/app/components：存储我定义的一些可复用的<strong>指令</strong>；</li>
<li>path-to-your-project/src/app/interceptors：存储我定义的一些<strong>拦截器</strong>；</li>
<li>path-to-your-project/src/app/interfaces：存储我定义的一些<strong>接口</strong>；</li>
<li>path-to-your-project/src/app/pipes：存储我定义的一些<strong>管道</strong>；</li>
<li>path-to-your-project/src/app/service：存储我定义的一些<strong>服务</strong>；</li>
<li>path-to-your-project/src/app/utils：存储我定义的一些<strong>杂项</strong>；</li>
<li>path-to-your-project/src/app/views：存储我定义的一些<strong>视图组件</strong>。</li>
</ul>
<h2 id="界面部分">界面部分</h2>
<ul>
<li>
<h3 id="左侧导航菜单">左侧导航菜单</h3>
全功能列表存在如下文件中：
<em><strong>path-to-your-project/src/app/_nav.ts</strong></em>
TIPS：
<ul>
<li>与原框架相比，<code>NavData</code> 接口增加 <code>pcode?: string;</code>，<code>pcode</code> 对应于后台权限表中的某个权限的权限代码，登录时后台会以正则表达式字面量的形式返回当前用户所具有的所有权限，我会 test 这个 RegExp 与这些 pcode，true 则添加。如果某元素不含有 <code>pcode</code> 这个 property，则默认添加；</li>
<li>只支持一层 <code>children</code> 嵌套，更深层次的嵌套不被解析；</li>
<li><code>icon</code> 这个 property 是定义导航 item 的左侧图标的，原模板已经引入了一些图标，我有根据具体功能，新引入了几个阿里出品的开源图标，可根据具体业务功能类型添加。</li>
</ul>
</li>
<li>
<h3 id="主区域-tab-页">主区域 TAB 页</h3>
Tab 页单击选中，双击关闭，Tab头可拖动，Tab 页最少会留一个“新标签页”。</li>
</ul>
<h2 id="路由设置">路由设置</h2>
<p><em><strong>path-to-your-project/src/app/app.routing.ts</strong></em></p>
<pre><code>...
children: [
      {
        path: 'new-tab',
        component: NewTabComponent,
        data: {
          title: '新标签页',
          cid: '041FF088415C6BBF458F9475FEE79986'
        }
      },
      {
        path: 'system',
        canLoad: [CanLoadGuard],
        data: {pcode: '001'},
        loadChildren: () =&gt; import('./views/system/system.module').then(m =&gt; m.SystemModule)
      }
    ]
...
</code></pre>
<p><em><strong>path-to-your-project/app/views/system/system-routing.module.ts</strong></em></p>
<pre><code>...
children: [
    {
      path: 'people',
      component: PeopleComponent,
      data: {
        title: '自然人管理',
        cid: '88C9EF4BD6306E26D3D2DA01FC2BB0FE',
        pcode: '001001',
        reuse: true
      }
    }]
...
</code></pre>
<h2 id="我写的一些公共功能的使用">我写的一些公共功能的使用</h2>
<p><strong>基本上都可以在“自然人管理”这个例子下找到使用方法（要使用，先引入相关模块）</strong></p>
<ul>
<li><strong>datatable</strong> 是一个组件，相关设置通过属性传值，组件选择器与接口格式如下：
<em><strong>path-to-your-project/src/app/views/system/people/people.component.html</strong></em></li>
</ul>
<pre><code class="language-html">&lt;app-rd-datatable #tb [rdTHead]=&quot;thead&quot; [rdTbConfig]=&quot;tbConfig&quot; (selectedRows)=&quot;setSelectedRows($event)&quot;&gt;&lt;/app-rd-datatable&gt;
</code></pre>
<p><em><strong>path-to-your-project/src/app/views/system/people/people.component.ts</strong></em></p>
<pre><code class="language-typescript">thead: Array&lt;Array&lt;RdDatatableThTd&gt;&gt; = [
    [
      {content: '姓名', style: {width: '15%'}},
      {content: '性别', style: {width: '10%'}},
      {content: '电话', style: {width: '15%'}},
      {content: '电子邮件', style: {width: '20%'}},
      {content: '身份证', style: {width: '25%'}},
      {content: '是否冻结', style: {width: '15%'}}
    ]
  ];
  tbConfig: RdDatatableConf = {
    url: 'system/people',
    hasCheckBox: true,
    rowsPrefetch: 100,
    rowsPerPage: 5,
    rowsTimes: [1, 2, 4, 6]
  };
</code></pre>
<ul>
<li><strong>datalist-validator</strong> 是一个指令，当表单中有长列表形式的域需要校验时，往往可以用到这个指令，如：
<em><strong>path-to-your-project/src/app/views/system/people/people.component.html</strong></em></li>
</ul>
<pre><code class="language-html">&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;country&quot; list=&quot;psy&quot; formControlName=&quot;country&quot; placeholder=&quot;请选择国家&quot; [appRdDatalist]=&quot;countrys4V&quot;/&gt;
</code></pre>
<p><em><strong>path-to-your-project/src/app/views/system/people/people.component.ts</strong></em></p>
<pre><code class="language-typescript">this.countrys4V = this.countrys.map(e =&gt; e.countryName);
</code></pre>
<ul>
<li><strong>http-interceptor</strong> 现在里面写了做四种功能的拦截，仅仅是提一下：
<ul>
<li>多线路选择与格式化请求的 URL ；</li>
<li>填充必要 HEADERS；</li>
<li>会话超时提示用户重新登录；</li>
<li>打印请求日志；</li>
<li>(TODO) 本地数据源代理。</li>
</ul>
</li>
<li><strong>interfaces</strong> 里写了一堆接口，根据名字很容易看出功能。</li>
<li><strong>pipes</strong> 里写了一个管道，用来在 datatable 显示的时候，自动加入 checkbox 使用。</li>
<li><strong>utils</strong> 里写了两个 snippets，一个用于依赖注入的 Token 用于在请求拦截器里依赖注入备选URL数组，全局配置信息和响应式表单校验器。</li>
<li><strong>login</strong> 登录页的表单是用了模板驱动表单，另外还有上面提到的响应式表单（自然人管理里用到）有示例。</li>
<li><strong>services</strong> 一般都是根注入，这些都是类注入，关于非类注入，上面有一个全局配置信息的对象注入：
<ul>
<li><strong>can-load.guard</strong> 路由守卫，在上面配置路由时出现过，根据用户权限，判断应否 load 某模块，这只是其中一个守卫，另外还应有判断应否 Active 等的守卫；</li>
<li><strong>rd-auth.service</strong>判断权限使用，包括判断用户是否登录和是否具有其试图触发路由的权限；</li>
<li><strong>rd-browser-storage.service</strong> 根据 Angular 预置 Token，使用的是 LocalStorage 方式的存储，现在存了选举出的URL、用户权限正则字面量和用户是否登录。</li>
<li><strong>rd-http.service</strong> 原则支持 RESTful，支持超时、重试、防抖等功能。支持带状态反馈的文件上传功能。</li>
<li><strong>rd-message.service</strong> 一个简单日志打印服务，可扩充至复杂日志系统。</li>
<li><strong>rd-modal.service</strong> Modal 功能，使用方法如下：</li>
</ul>
</li>
</ul>
<pre><code class="language-typescript">...
this.rdModal.onHidden().subscribe(reason =&gt; {
  switch (reason) {
    case 'secondLogin':
      this.login(true);
      break;
    case 'loginFailed':
      this.formData.password = '';
      break;
  }
});
...
const modalOptions = {
  animated: true,
  initialState: {
    title: '用户登录提示',
    content: '此用户已在别处登录，继续登录会将其踢下线，是否继续？',
    btnSecondary: '否',
    btnPrimary: '是',
    reasonPositive: 'secondLogin',
    type: 'danger'
  },
  class: 'modal-danger'
};
this.rdModal.show(modalOptions);
...
</code></pre>
<ul>
<li><strong>rd-reuse-strategy</strong> 路由策略</li>
<li><strong>rd-ws.service</strong> WebSocket
<ul>
<li>支持重连；</li>
<li>支持心跳；</li>
<li>支持恶意请求或超时时的策略；</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx 实现负载均衡有三种策略]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/three-way-of-nginx-for-load-balancing</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/three-way-of-nginx-for-load-balancing">
        </link>
        <updated>2019-06-26T01:42:06.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>轮询调度算法（Round-Robin）</strong>
轮询调度算法的原理，就是是把用户的请求按照顺序的轮流分配给app server，不断循环。</li>
<li><strong>最少连接（least-connected）</strong>
Nginx 会找出最少的连接的服务器出来，把用户的请求分配到该台app server。</li>
<li><strong>IP散列算法（ip-hash）</strong>
根据用户请求的IP，通过散列算法把请求分配到不同的服务器上。
IP-HASH 和 session 同步有关，这个算法的大致原理就是，根据请求的目标IP地址，作为散列键从静态分配的散列表找出对应的服务器，然后根据这台服务器的负载能力进行转发。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 下 Vmware 虚拟出的几个网卡设备及其作用]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/names-and-functions-of-several-virtual-nic-created-by-vmware-on-windows</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/names-and-functions-of-several-virtual-nic-created-by-vmware-on-windows">
        </link>
        <updated>2019-06-26T01:34:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="名称及作用">名称及作用：</h3>
<ul>
<li><strong>VMnet0</strong>：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；</li>
<li><strong>VMnet1</strong>：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；</li>
<li><strong>VMnet8</strong>：这是 VMware 用于虚拟NAT网络下的虚拟交换机；</li>
<li><strong>VMware Network Adapter VMnet1</strong>：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；</li>
<li><strong>VMware Network Adapter VMnet8</strong>：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；</li>
</ul>
<h3 id="桥接和-nat-的区别">桥接和 NAT 的区别：</h3>
<ul>
<li><strong>桥接</strong>：就是通过一台设备（可能不止一个）把几个网络串起来形成的连接。
<em><strong>数据流向</strong></em>：虚拟机系统-&gt;真实网卡-&gt;路由器-&gt;真实网卡-&gt;实体机系统。</li>
<li><strong>NAT模式</strong>： 实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。
<em><strong>虚拟机发送数据给实体机</strong></em>：虚拟机系统-&gt;虚拟网卡-&gt;实体机系统（可以发现是不经过真实网卡的流程简单很多）；
<em><strong>虚拟机访问外网</strong></em>：虚拟机系统-&gt;虚拟网卡-&gt;实体机系统-&gt;真实网卡-&gt;路由器-&gt;外网。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见算法英文缩写]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/english-abbreviations-of-common-algorithms</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/english-abbreviations-of-common-algorithms">
        </link>
        <updated>2019-06-26T01:32:42.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>BF</strong> - 暴力匹配算法</li>
<li><strong>DP</strong> - 动态规划</li>
<li><strong>BST</strong> - 二叉搜索树</li>
<li><strong>RBT</strong> - 红黑树</li>
<li><strong>DC</strong> - 分治算法</li>
<li><strong>TS</strong> - 拓扑</li>
<li><strong>KNN</strong> -邻近算法</li>
<li><strong>SNN</strong> -脉冲神经网络</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[几种括号的中英文名称]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/several-names-of-brackets</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/several-names-of-brackets">
        </link>
        <updated>2019-06-26T01:30:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>{ }</strong> braces 或 curly brackets 大括号</li>
<li><strong>[ ]</strong>  square brackets 或 brackets 方括号</li>
<li><strong>&lt; &gt;</strong> angled brackets 尖括号</li>
<li><strong>( )</strong> parentheses 圆括号</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[精力管理的几种方法]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/ways-to-manage-your-energy</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/ways-to-manage-your-energy">
        </link>
        <updated>2019-06-26T01:28:23.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>减少内耗；</li>
<li>学会聚焦，降低任务切换频率；</li>
<li>学会真正的休息，找到最适合自己的休息方式。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UX 十诫]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/top-ten-rules-of-ux</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/top-ten-rules-of-ux">
        </link>
        <updated>2019-06-26T01:27:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>从好的默认设定开始；</li>
<li>记住一切你应该记住的；</li>
<li>使用用户的语言讲话；</li>
<li>别让用户去做本该你做的事情；</li>
<li>别让边缘情况支配主流场景；</li>
<li>别让用户去思考；</li>
<li>别让用户来确认；</li>
<li>支持撤销；</li>
<li>恰到好处的可定制程度；</li>
<li>引导用户。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重构最佳实践]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/the-best-practice-in-code-refactoring</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/the-best-practice-in-code-refactoring">
        </link>
        <updated>2019-06-26T01:16:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>重构：</strong></p>
<ul>
<li>在不改变代码外部行为的情况下修改源代码</li>
</ul>
<p><strong>重构目的：</strong></p>
<ul>
<li>精简代码，规范化代码，模块化代码，删除无用代码；</li>
<li>统一基础类库，统一相同功能的实现方式；</li>
<li>提高性能。</li>
</ul>
<p><strong>重构最佳实践：</strong></p>
<ul>
<li>重构前一定要预估风险。如果没有足够的自动化测试，最好是先完善自动化测试代码；</li>
<li>重构的目的和范围要明确，切忌盲目修改。前端代码的重构目的主要是提高代码的可维护性，可读性和性能；</li>
<li>最好是先易后难，循序渐进。首先修改诸如命名，格式等不涉及具体逻辑的内容, 然后考虑模块化和性能提升等与具体逻辑相关的内容；</li>
<li>重构过程中要持续测试，在多个浏览器中测试，确保重构的部分功能正确。切忌在大量重构后再进行测试，因为大量重构后基本很难记得重构的逻辑，也就有可能遗漏部分测试用例；</li>
<li>如果是性能提升，要事先检测网站的整体性能并量化，找出性能瓶颈。重构过程中要持续监控性能，并对比性能提升的效果。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为什么有的编程规范要求用 void 0 代替 undefined ?]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/why-void-0-rather-than-undefined</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/why-void-0-rather-than-undefined">
        </link>
        <updated>2019-06-26T01:12:53.000Z</updated>
        <content type="html"><![CDATA[<p><code>Undefined</code> 类型表示未定义，它的类型只有一个值，就是 <code>undefined</code>。任何变量在赋值前是 <code>Undefined</code> 类型、值为 <code>undefined</code>，一般我们可以用全局变量 <code>undefined</code>（就是名为 <code>undefined</code> 的这个变量）来表达这个值，或者 <code>void</code> 运算来把任意一个表达式变成 <code>undefined</code> 值。</p>
<p>但是呢，因为 <code>JavaScript</code> 的代码 <code>undefined</code> 是一个变量，而并非是一个关键字，这是 <code>JavaScript</code> 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 <code>void 0</code> 来获取 <code>undefined</code> 值。</p>
<p>——来自《重学前端》</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BT 搜索网站]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/awesome-websites-of-bit-torrents-search-engine</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/awesome-websites-of-bit-torrents-search-engine">
        </link>
        <updated>2019-06-25T01:29:20.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><a href="https://cachetorrent.com/">LimeTorrents - Download Verified Torrents</a></li>
<li><a href="http://www.pushbt2.com/">PushBT平台|推送BT</a></li>
<li><a href="https://www.cilisharez.com/">btsearchs_bt种子搜索器网站</a></li>
<li><a href="https://www.cl8.biz/">最佳的磁力搜索引擎-磁力吧</a></li>
</ul>
]]></content>
    </entry>
</feed>