<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tdmaker.github.io/randy-blogs/</id>
    <title>性感知识，在线分享</title>
    <updated>2019-07-12T02:09:37.106Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tdmaker.github.io/randy-blogs/"/>
    <link rel="self" href="https://tdmaker.github.io/randy-blogs//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tdmaker.github.io/randy-blogs//images/avatar.png</logo>
    <icon>https://tdmaker.github.io/randy-blogs//favicon.ico</icon>
    <rights>All rights reserved 2019, 性感知识，在线分享</rights>
    <entry>
        <title type="html"><![CDATA[为什么 2/3 的会议都是低效或无效的？]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/why-2-of-3-meetings-are-inefficient-or-ineffective</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/why-2-of-3-meetings-are-inefficient-or-ineffective">
        </link>
        <updated>2019-07-12T01:56:04.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>会议是在公司内部用来传递、沟通信息以及达成决策的工具</strong>。越是高层级的管理者，在会议上花的时间越多。哈佛商学院做了个统计，每周管理者要花18小时以上(1/3的时间)在会议上，但是，众多的会议并未达到预期的目的，25-50%的会议时间被认为是在浪费时间。人们对开会怨声载道，认为开会是浪费时间。</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>会议是在公司内部用来传递、沟通信息以及达成决策的工具</strong>。越是高层级的管理者，在会议上花的时间越多。哈佛商学院做了个统计，每周管理者要花18小时以上(1/3的时间)在会议上，但是，众多的会议并未达到预期的目的，25-50%的会议时间被认为是在浪费时间。人们对开会怨声载道，认为开会是浪费时间。</p>
 <!-- more -->
<p><strong>能否开好会议，是高效管理者和普通管理者之间的区别</strong>。</p>
<p>因为会议决定了你的执行效率。那我们一起来看看如何能开好一场会议。</p>
<p>给大家举个例子，产品部的小李在吃过午饭后接到了会议通知，这个通知提到了下午2点在二楼会议室开会。</p>
<p>小李准时前来开会，看到许多同事都已经在了，包括市场、财务、开发部门的同事。于是小李就问大家这次会议开什么内容，大家都面面相觑，说都是刚刚接到通知。不一会，业务部的负责人张总来了，说召集大家讨论一下这一批产品上市后用户的反馈和应对，然后花了半小时介绍了目前事情的背景和情况。经过一下午的讨论，大家从各自的角度出发提出了很多观点。会议结束了，第二天小李继续着手进行了原来的工作，前一天的会议内容就被她抛之脑后了。这是一个非常常见的会议的情形。我们一起来看看这场会议存在哪些问题，还有哪些地方值得提升。</p>
<p>第一个严重的误区和问题，也是多数会议都会有的通病：
如果我们开个一小时的会议，从下午1点到2点。这个会议所用的时间资源，也就是所谓会议时长，是一小时。但是这个会议所覆盖的时间周期可不止一小时。</p>
<p>如果想要一个会议有成效，我们必须要关注到<strong>会议前</strong>与<strong>会议后</strong>的这两个重要时间段：</p>
<h1 id="会议前">会议前</h1>
<p>我们需要做什么?创办人想要创办一个好的会议，在时间条件允许的情况下，要提前24小时给参会人员发出会议的通告，要告诉与会者这次会议的：</p>
<ol>
<li>目的</li>
<li>时间、地点</li>
<li>需要阅读的材料和要准备的信息</li>
</ol>
<p>会议是一个特别耗费时间的活动。例如一个一小时的会议，如果有八个人来参加，那么这场会议不仅仅耗费了参会人员一小时的时间，还等同于耗费了公司八个小时的生产力。因此，对于一个团队和公司来说，<strong>开好一场会议的前提是会议的内容需要集体来交流以及做决策</strong>。</p>
<p>如果一场会议的目的仅仅是让参会人了解信息，像这种可以个人完成的任务，就没必要放在会议上解决了，这是许多会议都会出现的问题。参会人往往在进入会议室之前对本次会议的内容一无所知，以至于一场会议需要占用大量的时间来跟参会人普及背景信息知识。</p>
<p>其实，<strong>普及背景信息这项工作可以在会议前做</strong>，就是把相关信息发给即将参会的人员，让他们利用好各自的时间来了解这次会议的内容。只有在参会人充分准备的情况下，大家才能在会议的现场有效地交流、做决策，以及最终达成一致的结果。只有这样，会议才会变得高效。</p>
<h1 id="会议后">会议后</h1>
<p>当会议开完，会议门被关上的那一刹那，并不代表这场会议的结束，而只是进展了一半，因为会议上达成的决议还没有开始被大家执行。</p>
<p>因此，<strong>每场会议后都要得出清晰的会议纪要，明确要达成的目标和要完成的具体任务，以及任务的执行者和完成的时间</strong>。</p>
<p>这样的会议纪要要在会议后24小时发给与会人员，并要求相应的与会人员在确定的时间点对会议所要求的事情给予进展的反馈。那么，这样的会议才算是画了完整的句号的会议。</p>
<p>对于一场会议来说，重要的不仅是会议的成功举办，还要求会议是高效的，并且一定要关注会议前与会议后所要做的事情。<strong>除了需要注意会前和会后，会议的举办现场，也需要注意一些重要的事项</strong>。</p>
<h2 id="首先每一场会议一定要有一个明确的发起者或者叫做决策者">首先，每一场会议一定要有一个明确的发起者，或者叫做决策者。</h2>
<p>在一场会议当中，如果没有决策者和最终的负责人，这场会议就会变成一场漫无目的的空谈和讨论。因为<strong>会议的目的是做出一个决策，以及行动计划</strong>。即便这项决策可能不是最完美的，但这项决策需要有人来拍板。有时候在一场两个部门之间的会议中，如果没有一个更高层的角色来参与时，这样的会议很容易让大家都以妥协来收场。</p>
<h2 id="第二在会的时间观念包括参会一定要守时">第二，在会的时间观念包括参会一定要守时。</h2>
<p>在会议过程中，对于时间的把控要非常的严格。在很多情况下，参会人员会觉得这场会议已经没有要继续进行的意义了，但是没有人宣布会议的结束，所以参会人还得在这场会议中继续浪费时间。所以，<strong>主持人需要能够把握会议的议程</strong>。</p>
<p>一般来说，一个会议的议程可以包括以下几个步骤：</p>
<ul>
<li>表明目的</li>
<li>介绍简要的背景</li>
<li>提供决策信息</li>
<li>表达观点</li>
<li>达成一致</li>
</ul>
<p>在会议的讨论过程当中，要确保每一位角色都能发表各自的观点，如果你发现某些角色，在整场会议中不需要发表观点，或是从来都不发表观点，那么这样的角色未来可能就不需要参与这样的会议了。</p>
<h2 id="第三杜绝在会议当中的小会议和子会议">第三，杜绝在会议当中的小会议和子会议。</h2>
<p>每个人讨论的观点都应该让所有人听到，要杜绝他们与身边的人进行交头接耳沟通的情况。有时候一场会议会引申出一些新的议题。那这个时候，会议的管理者需要意识到这些问题可能会用一场新的会议来解决，而不应该在这场会议中进行讨论解决。</p>
<h2 id="第四要严格控制会议的规模">第四，要严格控制会议的规模。</h2>
<p>通常要求便于管理即可，一般与会者最好不要超过八个人，十个人是上限。</p>
<p>在会议的过程当中，尽量保留用于放幻灯片以及用于做记录的电脑。如果一些人员带着电脑来参会，这将是一个非常低效的行为，因为经常需要把这些人员重新拉回讨论现场。另外<strong>微信也是会议效率的杀手</strong>，除非有非常要紧的事，或者客户急需解决问题。否则，一边开会一边浏览手机将是非常低效的。</p>
<p><strong>对于参会人来说，要学会说不</strong>。如果觉得这个会议确实不用参与，参会人可以拒绝，而不用勉强去参加一场全程都很讨厌的会。</p>
<p>成员对于会议的决策可以在会议现场提出不同的意见。但是一旦达成一致，哪怕你有保留意见，也要百分之百的完全执行。</p>
<p>有些公司或团队采用站立式开会的方式也是一种不错的选择，至少这样的会议不会开得很长。</p>
<p><strong>下次开会的时候，检查一下这些点。一个好的团队管理者，一定是关注细节的</strong>。</p>
<blockquote>
<p>来自<a href="https://www.jianshu.com/p/4c85cd4d7d9b">《议事法则｜为什么 2/3 的会议都是低效或无效的？》</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[30 条编程名言佳句]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/30-tiao-bian-cheng-ming-yan-jia-ju</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/30-tiao-bian-cheng-ming-yan-jia-ju">
        </link>
        <updated>2019-07-05T02:57:38.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>生命太短暂，不要去做一些根本没有人想要的东西。——Ash Maurya</p>
</li>
<li>
<p>如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子。——David Leinweber</p>
</li>
<li>
<p>软件设计有两种方式：一种方式是，使软件过于简单，明显没有缺陷；另一种方式是，使软件过于复杂，没有明显的缺陷。——C.A.R. Hoare</p>
</li>
<li>
<p>其实，我尝试着使 Ruby 更自然，而不是简单。Ruby 看起来很简单，但内部是非常复杂的，就像我们的身体一样。——松本行弘，Ruby 之父</p>
</li>
<li>
<p>大部分情况下，构建程序的过程本质上是对规范调试的过程。——Fred Brooks，《人月神话》作者</p>
</li>
<li>
<p>软件开发往往是这样：最开始的 90% 代码占用了开始的 90% 的开发时间；剩下 10% 代码同样需要 90% 的开发时间。——Tom Cargill</p>
</li>
<li>
<p>当你试图解决一个你不理解的问题时，复杂化就产成了。——Andy Boothe</p>
</li>
<li>
<p>用几个小时来制定计划，可以节省几周的编程时间。—— 匿名</p>
</li>
<li>
<p>控制复杂性是计算机编程的本质。—— Brian Kernighan</p>
</li>
<li>
<p>计算机科学领域的所有问题都可以通过其他方式间接解决。——David Wheeler</p>
</li>
<li>
<p>编程是两队人马在竞争：软件工程师努力设计出最大最好的连白痴都会使用的程序；而宇宙在拼命制造最大最好的白痴。到目前为止，宇宙是胜利者。—— Rick Cook</p>
</li>
<li>
<p>调试一个初次见到的代码比重写代码要困难两倍。因此，按照定义，如果你写代码非常巧妙，那么没有人足够聪明来调试它。—— Brian W. Kernighan</p>
</li>
<li>
<p>我不是一个伟大的程序员，我只是一个具有良好习惯的优秀程序员。― Kent Beck</p>
</li>
<li>
<p>你们中大多数人都熟悉程序员的美德，有三种：那就是懒惰、急躁和傲慢。- Larry Wall，Perl 語言发明人</p>
</li>
<li>
<p>任何一个傻瓜都会写能够让机器理解的代码，只有好的程序员才能写出人类可以理解的代码。——Martin Fowler</p>
</li>
<li>
<p>靠代码行数来衡量开发进度，就像是凭重量来衡量飞机制造的进度。——比尔·盖茨</p>
</li>
<li>
<p>这不是一个 bug，这只是一个未列出来的特性。——匿名</p>
</li>
<li>
<p>作为一个程序员，郁闷的事情是，面对一个代码块，却不敢去修改。更糟糕的是，这个代码块还是自己写的。—— Peyton Jones</p>
</li>
<li>
<p>它在我的机器上可以很好运行！——大部分程序员</p>
</li>
<li>
<p>能说算不上什么，有本事就把你的代码给我看看。——Linus Torvalds，Linux 之父</p>
</li>
<li>
<p>我认为对象就像是生物学里的细胞，或者网络中的一台计算机，只能够通过消息来通信——Alan Kay，Smalltalk 的发明人，面向对象之父</p>
</li>
<li>
<p>当你选择了一种语言，意味着你还选择了一组技术、一个社区。——Joshua Bloch</p>
</li>
<li>
<p>质量、速度、廉价，选择其中两个。——匿名</p>
</li>
<li>
<p>过早的优化是罪恶之源。——Donald Knuth</p>
</li>
<li>
<p>没有什么代码的执行速度比空代码更快。——Merb 核心原则</p>
</li>
<li>
<p>如果你是房间里最聪明的人，那么你走错房间了。——匿名</p>
</li>
<li>
<p>如果只需更改一个单一的代码行，你的部门需要花费多长时间？——Mary Poppendieck</p>
</li>
<li>
<p>九个人不能让一个孩子在一个月内出生。——Fred Brooks，《人月神话》作者</p>
</li>
<li>
<p>好代码本身就是最好的文档。当你需要添加一个注释时，你应该考虑如何修改代码才能不需要注释。——Steve McConnell，Code Complete 作者</p>
</li>
<li>
<p>一个人在教会电脑之前，别说他真正理解这个东西了。——Donald Knuth</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对于医疗项目框架的讲述——前端部分]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/an-explanation-of-medical-frameworks</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/an-explanation-of-medical-frameworks">
        </link>
        <updated>2019-06-26T05:54:00.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><em>只讲组织结构和如何使用，如何实现可以看源码。不涉及怎样使用 Angular 以及其他相关技术</em></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><em>只讲组织结构和如何使用，如何实现可以看源码。不涉及怎样使用 Angular 以及其他相关技术</em></p>
</blockquote>
<!--more-->
<h2 id="目录结构">目录结构</h2>
<ul>
<li>path-to-your-project/src/app/components：存储我定义的一些<strong>可复用组件</strong>，作用根据名称一目了然；</li>
<li>path-to-your-project/src/app/container：存储网站主<strong>业务框架</strong>；</li>
<li>path-to-your-project/src/app/components：存储我定义的一些可复用的<strong>指令</strong>；</li>
<li>path-to-your-project/src/app/interceptors：存储我定义的一些<strong>拦截器</strong>；</li>
<li>path-to-your-project/src/app/interfaces：存储我定义的一些<strong>接口</strong>；</li>
<li>path-to-your-project/src/app/pipes：存储我定义的一些<strong>管道</strong>；</li>
<li>path-to-your-project/src/app/service：存储我定义的一些<strong>服务</strong>；</li>
<li>path-to-your-project/src/app/utils：存储我定义的一些<strong>杂项</strong>；</li>
<li>path-to-your-project/src/app/views：存储我定义的一些<strong>视图组件</strong>。</li>
</ul>
<h2 id="界面部分">界面部分</h2>
<ul>
<li>
<h3 id="左侧导航菜单">左侧导航菜单</h3>
全功能列表存在如下文件中：
<em><strong>path-to-your-project/src/app/_nav.ts</strong></em>
TIPS：
<ul>
<li>与原框架相比，<code>NavData</code> 接口增加 <code>pcode?: string;</code>，<code>pcode</code> 对应于后台权限表中的某个权限的权限代码，登录时后台会以正则表达式字面量的形式返回当前用户所具有的所有权限，我会 test 这个 RegExp 与这些 pcode，true 则添加。如果某元素不含有 <code>pcode</code> 这个 property，则默认添加；</li>
<li>只支持一层 <code>children</code> 嵌套，更深层次的嵌套不被解析；</li>
<li><code>icon</code> 这个 property 是定义导航 item 的左侧图标的，原模板已经引入了一些图标，我有根据具体功能，新引入了几个阿里出品的开源图标，可根据具体业务功能类型添加。</li>
</ul>
</li>
<li>
<h3 id="主区域-tab-页">主区域 TAB 页</h3>
Tab 页单击选中，双击关闭，Tab头可拖动，Tab 页最少会留一个“新标签页”。</li>
</ul>
<h2 id="路由设置">路由设置</h2>
<p><em><strong>path-to-your-project/src/app/app.routing.ts</strong></em></p>
<pre><code>...
children: [
      {
        path: 'new-tab',
        component: NewTabComponent,
        data: {
          title: '新标签页',
          cid: '041FF088415C6BBF458F9475FEE79986'
        }
      },
      {
        path: 'system',
        canLoad: [CanLoadGuard],
        data: {pcode: '001'},
        loadChildren: () =&gt; import('./views/system/system.module').then(m =&gt; m.SystemModule)
      }
    ]
...
</code></pre>
<p><em><strong>path-to-your-project/app/views/system/system-routing.module.ts</strong></em></p>
<pre><code>...
children: [
    {
      path: 'people',
      component: PeopleComponent,
      data: {
        title: '自然人管理',
        cid: '88C9EF4BD6306E26D3D2DA01FC2BB0FE',
        pcode: '001001',
        reuse: true
      }
    }]
...
</code></pre>
<h2 id="我写的一些公共功能的使用">我写的一些公共功能的使用</h2>
<p><strong>基本上都可以在“自然人管理”这个例子下找到使用方法（要使用，先引入相关模块）</strong></p>
<ul>
<li><strong>datatable</strong> 是一个组件，相关设置通过属性传值，组件选择器与接口格式如下：
<em><strong>path-to-your-project/src/app/views/system/people/people.component.html</strong></em></li>
</ul>
<pre><code class="language-html">&lt;app-rd-datatable #tb [rdTHead]=&quot;thead&quot; [rdTbConfig]=&quot;tbConfig&quot; (selectedRows)=&quot;setSelectedRows($event)&quot;&gt;&lt;/app-rd-datatable&gt;
</code></pre>
<p><em><strong>path-to-your-project/src/app/views/system/people/people.component.ts</strong></em></p>
<pre><code class="language-typescript">thead: Array&lt;Array&lt;RdDatatableThTd&gt;&gt; = [
    [
      {content: '姓名', style: {width: '15%'}},
      {content: '性别', style: {width: '10%'}},
      {content: '电话', style: {width: '15%'}},
      {content: '电子邮件', style: {width: '20%'}},
      {content: '身份证', style: {width: '25%'}},
      {content: '是否冻结', style: {width: '15%'}}
    ]
  ];
  tbConfig: RdDatatableConf = {
    url: 'system/people',
    hasCheckBox: true,
    rowsPrefetch: 100,
    rowsPerPage: 5,
    rowsTimes: [1, 2, 4, 6]
  };
</code></pre>
<ul>
<li><strong>datalist-validator</strong> 是一个指令，当表单中有长列表形式的域需要校验时，往往可以用到这个指令，如：
<em><strong>path-to-your-project/src/app/views/system/people/people.component.html</strong></em></li>
</ul>
<pre><code class="language-html">&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;country&quot; list=&quot;psy&quot; formControlName=&quot;country&quot; placeholder=&quot;请选择国家&quot; [appRdDatalist]=&quot;countrys4V&quot;/&gt;
</code></pre>
<p><em><strong>path-to-your-project/src/app/views/system/people/people.component.ts</strong></em></p>
<pre><code class="language-typescript">this.countrys4V = this.countrys.map(e =&gt; e.countryName);
</code></pre>
<ul>
<li><strong>http-interceptor</strong> 现在里面写了做四种功能的拦截，仅仅是提一下：
<ul>
<li>多线路选择与格式化请求的 URL ；</li>
<li>填充必要 HEADERS；</li>
<li>会话超时提示用户重新登录；</li>
<li>打印请求日志；</li>
<li>(TODO) 本地数据源代理。</li>
</ul>
</li>
<li><strong>interfaces</strong> 里写了一堆接口，根据名字很容易看出功能。</li>
<li><strong>pipes</strong> 里写了一个管道，用来在 datatable 显示的时候，自动加入 checkbox 使用。</li>
<li><strong>utils</strong> 里写了两个 snippets，一个用于依赖注入的 Token 用于在请求拦截器里依赖注入备选URL数组，全局配置信息和响应式表单校验器。</li>
<li><strong>login</strong> 登录页的表单是用了模板驱动表单，另外还有上面提到的响应式表单（自然人管理里用到）有示例。</li>
<li><strong>services</strong> 一般都是根注入，这些都是类注入，关于非类注入，上面有一个全局配置信息的对象注入：
<ul>
<li><strong>can-load.guard</strong> 路由守卫，在上面配置路由时出现过，根据用户权限，判断应否 load 某模块，这只是其中一个守卫，另外还应有判断应否 Active 等的守卫；</li>
<li><strong>rd-auth.service</strong>判断权限使用，包括判断用户是否登录和是否具有其试图触发路由的权限；</li>
<li><strong>rd-browser-storage.service</strong> 根据 Angular 预置 Token，使用的是 LocalStorage 方式的存储，现在存了选举出的URL、用户权限正则字面量和用户是否登录。</li>
<li><strong>rd-http.service</strong> 原则支持 RESTful，支持超时、重试、防抖等功能。支持带状态反馈的文件上传功能。</li>
<li><strong>rd-message.service</strong> 一个简单日志打印服务，可扩充至复杂日志系统。</li>
<li><strong>rd-modal.service</strong> Modal 功能，使用方法如下：</li>
</ul>
</li>
</ul>
<pre><code class="language-typescript">...
this.rdModal.onHidden().subscribe(reason =&gt; {
  switch (reason) {
    case 'secondLogin':
      this.login(true);
      break;
    case 'loginFailed':
      this.formData.password = '';
      break;
  }
});
...
const modalOptions = {
  animated: true,
  initialState: {
    title: '用户登录提示',
    content: '此用户已在别处登录，继续登录会将其踢下线，是否继续？',
    btnSecondary: '否',
    btnPrimary: '是',
    reasonPositive: 'secondLogin',
    type: 'danger'
  },
  class: 'modal-danger'
};
this.rdModal.show(modalOptions);
...
</code></pre>
<ul>
<li><strong>rd-reuse-strategy</strong> 路由策略</li>
<li><strong>rd-ws.service</strong> WebSocket
<ul>
<li>支持重连；</li>
<li>支持心跳；</li>
<li>支持恶意请求或超时时的策略；</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx 实现负载均衡有三种策略]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/three-way-of-nginx-for-load-balancing</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/three-way-of-nginx-for-load-balancing">
        </link>
        <updated>2019-06-26T01:42:06.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>轮询调度算法（Round-Robin）</strong>
轮询调度算法的原理，就是是把用户的请求按照顺序的轮流分配给app server，不断循环。</li>
<li><strong>最少连接（least-connected）</strong>
Nginx 会找出最少的连接的服务器出来，把用户的请求分配到该台app server。</li>
<li><strong>IP散列算法（ip-hash）</strong>
根据用户请求的IP，通过散列算法把请求分配到不同的服务器上。
IP-HASH 和 session 同步有关，这个算法的大致原理就是，根据请求的目标IP地址，作为散列键从静态分配的散列表找出对应的服务器，然后根据这台服务器的负载能力进行转发。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows 下 Vmware 虚拟出的几个网卡设备及其作用]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/names-and-functions-of-several-virtual-nic-created-by-vmware-on-windows</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/names-and-functions-of-several-virtual-nic-created-by-vmware-on-windows">
        </link>
        <updated>2019-06-26T01:34:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="名称及作用">名称及作用：</h3>
<ul>
<li><strong>VMnet0</strong>：这是 VMware 用于虚拟桥接网络下的虚拟交换机，一般是不可见的，因为桥接一般直接使用真实网卡；</li>
<li><strong>VMnet1</strong>：这是 VMware 用于虚拟Host-Only网络下的虚拟交换机；</li>
<li><strong>VMnet8</strong>：这是 VMware 用于虚拟NAT网络下的虚拟交换机；</li>
<li><strong>VMware Network Adapter VMnet1</strong>：这是 Host 用于与 Host-Only 虚拟网络进行通信的虚拟网卡；</li>
<li><strong>VMware Network Adapter VMnet8</strong>：这是 Host 用于与 NAT 虚拟网络进行通信的虚拟网卡；</li>
</ul>
<h3 id="桥接和-nat-的区别">桥接和 NAT 的区别：</h3>
<ul>
<li><strong>桥接</strong>：就是通过一台设备（可能不止一个）把几个网络串起来形成的连接。
<em><strong>数据流向</strong></em>：虚拟机系统-&gt;真实网卡-&gt;路由器-&gt;真实网卡-&gt;实体机系统。</li>
<li><strong>NAT模式</strong>： 实际是虚拟了一个网卡出来，虚拟机直接使用链接这个虚拟网卡，每次访问和交互通过这个虚拟网卡交换数据。
<em><strong>虚拟机发送数据给实体机</strong></em>：虚拟机系统-&gt;虚拟网卡-&gt;实体机系统（可以发现是不经过真实网卡的流程简单很多）；
<em><strong>虚拟机访问外网</strong></em>：虚拟机系统-&gt;虚拟网卡-&gt;实体机系统-&gt;真实网卡-&gt;路由器-&gt;外网。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见算法英文缩写]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/english-abbreviations-of-common-algorithms</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/english-abbreviations-of-common-algorithms">
        </link>
        <updated>2019-06-26T01:32:42.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>BF</strong> - 暴力匹配算法</li>
<li><strong>DP</strong> - 动态规划</li>
<li><strong>BST</strong> - 二叉搜索树</li>
<li><strong>RBT</strong> - 红黑树</li>
<li><strong>DC</strong> - 分治算法</li>
<li><strong>TS</strong> - 拓扑</li>
<li><strong>KNN</strong> -邻近算法</li>
<li><strong>SNN</strong> -脉冲神经网络</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[几种括号的中英文名称]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/several-names-of-brackets</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/several-names-of-brackets">
        </link>
        <updated>2019-06-26T01:30:01.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li><strong>{ }</strong> braces 或 curly brackets 大括号</li>
<li><strong>[ ]</strong>  square brackets 或 brackets 方括号</li>
<li><strong>&lt; &gt;</strong> angled brackets 尖括号</li>
<li><strong>( )</strong> parentheses 圆括号</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[精力管理的几种方法]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/ways-to-manage-your-energy</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/ways-to-manage-your-energy">
        </link>
        <updated>2019-06-26T01:28:23.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>减少内耗；</li>
<li>学会聚焦，降低任务切换频率；</li>
<li>学会真正的休息，找到最适合自己的休息方式。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UX 十诫]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/top-ten-rules-of-ux</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/top-ten-rules-of-ux">
        </link>
        <updated>2019-06-26T01:27:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>从好的默认设定开始；</li>
<li>记住一切你应该记住的；</li>
<li>使用用户的语言讲话；</li>
<li>别让用户去做本该你做的事情；</li>
<li>别让边缘情况支配主流场景；</li>
<li>别让用户去思考；</li>
<li>别让用户来确认；</li>
<li>支持撤销；</li>
<li>恰到好处的可定制程度；</li>
<li>引导用户。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重构最佳实践]]></title>
        <id>https://tdmaker.github.io/randy-blogs//post/the-best-practice-in-code-refactoring</id>
        <link href="https://tdmaker.github.io/randy-blogs//post/the-best-practice-in-code-refactoring">
        </link>
        <updated>2019-06-26T01:16:23.000Z</updated>
        <content type="html"><![CDATA[<p><strong>重构：</strong></p>
<ul>
<li>在不改变代码外部行为的情况下修改源代码</li>
</ul>
<p><strong>重构目的：</strong></p>
<ul>
<li>精简代码，规范化代码，模块化代码，删除无用代码；</li>
<li>统一基础类库，统一相同功能的实现方式；</li>
<li>提高性能。</li>
</ul>
<p><strong>重构最佳实践：</strong></p>
<ul>
<li>重构前一定要预估风险。如果没有足够的自动化测试，最好是先完善自动化测试代码；</li>
<li>重构的目的和范围要明确，切忌盲目修改。前端代码的重构目的主要是提高代码的可维护性，可读性和性能；</li>
<li>最好是先易后难，循序渐进。首先修改诸如命名，格式等不涉及具体逻辑的内容, 然后考虑模块化和性能提升等与具体逻辑相关的内容；</li>
<li>重构过程中要持续测试，在多个浏览器中测试，确保重构的部分功能正确。切忌在大量重构后再进行测试，因为大量重构后基本很难记得重构的逻辑，也就有可能遗漏部分测试用例；</li>
<li>如果是性能提升，要事先检测网站的整体性能并量化，找出性能瓶颈。重构过程中要持续监控性能，并对比性能提升的效果。</li>
</ul>
]]></content>
    </entry>
</feed>